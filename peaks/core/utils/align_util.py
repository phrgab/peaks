#Functions used to perform data alignment
#Phil King 12/6/21
import warnings

import numpy as np
import matplotlib.pyplot as plt
import xarray as xr
from skimage.registration import phase_cross_correlation
from peaks.core.utils.get_angles import get_angles
from peaks.core.fileIO.fileIO_opts import BL_angles
from peaks.core.utils.misc import warning_simple, warning_standard
from peaks.core.utils.OOP_method import add_methods

def align_disp_old(data, plot=True, set_norm=False):
    ''' This function estimates the normal emission along a dispersion from cross-corrleation analysis

        Input:
            data - the data to be aligned (xarray)
            plot - whether to make a plot demonstrating alignment (bool, defaults to True)
            set_norm - whether to write the normal emission coordinates to the dataarray (bool, defaults to False)

        Returns:
            norm_emission - the estimated normal emission (dict) '''

    # Make a copy of the data
    data1 = data.copy(deep=True)

    # Check the dispersion has the correct axis ordering (this will be important for interpreting the raw np array below) and get the raw np array
    data1 = data1.transpose("theta_par", "eV").data

    # Get a flipped version of this around centre point of array
    data2 = np.flipud(data1)

    # Work out offset on theta_par scale with subpixel precision
    shift, error, diffphase = phase_cross_correlation(data1, data2, upsample_factor=100)
    dth = data.theta_par.data[1] - data.theta_par.data[0]  # theta_par pixel size
    th_mid = np.median(data.theta_par.data)  # Centre of theta_par scale
    th_off = np.round(th_mid + ((shift[0] / 2) * dth), 3)

    # Work out offset in manipulator angle
    norm_angles = get_norm(data, {'theta_par': th_off})

    # If asked to write these to the original dataarray
    if set_norm == True:
        for i in norm_angles:
            data.attrs[i] = norm_angles[i]
        # Give a warning
        warnings.simplefilter('always', UserWarning)  # Set warning display and formatting - Give warnings every time, even on function re-run
        warnings.formatwarning = warning_simple  # Formatting of warnings for peaks user errors
        warn_str = 'Normal emission angles written to original data: ' + str(norm_angles)
        warnings.warn(warn_str)
        warnings.simplefilter('once', UserWarning)  # Reset warnings display and formatting - Give warnings first time only
        warnings.formatwarning = warning_standard  # Formatting of warnings for peaks user errors

    if plot == True:
        # Take the cross-correlation of these
        image_product = np.fft.fft2(data1) * np.fft.fft2(data2).conj()
        corr = np.fft.fftshift(np.fft.ifft2(image_product))

        # Work out the correlation axis ranges
        Nth = corr.shape[0]
        th0 = -np.floor(Nth / 2) * dth
        corr_th_vals = np.linspace(th0, -th0, Nth)
        dE = data.eV.data[1] - data.eV.data[0]
        NE = corr.shape[1]
        E0 = -np.floor(NE / 2) * dE
        corr_E_vals = np.linspace(E0, -E0, NE)
        corr_xarray = xr.DataArray(corr.real, dims=['d_theta_par', 'd_eV'],
                                   coords={'d_theta_par': corr_th_vals, 'd_eV': corr_E_vals})

        # This is a dispersion, so assume there should be negligible energy shift in the flipped dispersion
        corr_slice = corr_xarray.sel(d_eV=slice(-0.01, 0.01)).mean('d_eV')

        # Set up the plot
        fig = plt.figure(figsize=(15,5))
        gs = fig.add_gridspec(5,3)
        ax1 = fig.add_subplot(gs[:,0])
        ax2 = fig.add_subplot(gs[:,1])
        ax3 = fig.add_subplot(gs[:-2,2])
        ax4 = fig.add_subplot(gs[-2:,2])

        # Plot the cross correlation
        corr_xarray.plot(y='d_eV',ax=ax1)
        ax1.set_title('Cross-correlation')

        # Plot the zero-energy slice
        corr_slice.plot(ax=ax2)
        ax2.axvline(shift[0]*dth)
        ax2.set_title('Cross-correlation - eV=0')

        # Plot the original data with the norm emission line
        data.plot(y='eV', ax=ax3)
        # And a zoom
        data.sel(theta_par=slice(th_off-1,th_off+1)).plot(y='eV', ax=ax4)
        ax3.axvline(th_off)
        ax4.axvline(th_off)
        ax3.set_title('Norm theta_par: ' + str(th_off) + '\nManipulator: '+str(norm_angles))
        plt.tight_layout()

    return norm_angles

def align_FS_old(data, plot=True, set_norm=False):
    ''' This function estimates the normal emission from a Fermi surface

        Input:
            data - the data to be aligned, Fermi surface single slice as e.g. generated by
              peaks.display.FS_display.FS (xarray)
            plot - whether to make a plot demonstrating alignment (bool, defaults to True)
            set_norm - whether to write the normal emission coordinates to the dataarray (bool, defaults to False)

        Returns:
            norm_emission - the estimated normal emission (float) '''

    # Make a copy of the data
    data_in = data.copy(deep=True)

    # Do a format check
    if len(data_in.dims) == 3:
        try:
            data_in = data_in.squeeze('eV')  # Should only have single eV value, if this is still a dim, get rid of this
        except:
            err_str = 'Data is too high dimension - ensure only a single eV value is present'
            raise Exception(err_str)

    # Wrok out relevant angular mapping dimension
    for i in data_in.dims:
        if i != 'theta_par':
            mapping_dim = i

    # Reindex array to ensure it has increasing angles with array pixel
    if data_in.theta_par.data[1] - data_in.theta_par.data[0] < 0:  # Array currently has decreasing order
        data_in = data_in.reindex(theta_par=data_in.theta_par[::-1])
    if data_in[mapping_dim].data[1] - data_in[mapping_dim].data[0] < 0:  # Array currently has decreasing order
        data_in = data_in.reindex({mapping_dim: data_in[mapping_dim][::-1]})

    # Check the dispersion has the correct axis ordering (this will be important for interpreting the raw np array below)
    data_in = data_in.transpose(mapping_dim, "theta_par")
    data1 = data_in.data  # Underlying np array

    # Get a version of this rotated by 180 deg
    data2 = np.rot90(data1, 2)  # np.rot90 applied two times

    # Work out offset with subpixel precision
    shift, error, diffphase = phase_cross_correlation(data1, data2, upsample_factor=100)
    dth = data_in.theta_par.data[1] - data_in.theta_par.data[0]  # theta_par pixel size
    th_mid = np.median(data_in.theta_par.data)  # Centre of theta_par scale
    dmap = data_in[mapping_dim].data[1] - data_in[mapping_dim].data[0]  # mapping angle pixel size
    mapping_mid = np.median(data_in[mapping_dim].data)
    
    # Work out estimated normal emissions (note map was rotated around centre point of array, not angles=0 so need to take care of that offset too
    map_off = np.round(mapping_mid + ((shift[0]/2) * dmap), 3)
    th_off = np.round(th_mid + ((shift[1]/2) * dth), 3)

    print(mapping_dim+': '+str(map_off))
    print('th: '+str(th_off))

    # Work out offset in manipulator angle
    norm_angles = get_norm(data, {'theta_par': th_off, mapping_dim: map_off})

    # If asked to write these to the original dataarray
    if set_norm == True:
        for i in norm_angles:
            data.attrs[i] = norm_angles[i]
        # Give a warning
        warnings.simplefilter('always', UserWarning)  # Set warning display and formatting - Give warnings every time, even on function re-run
        warnings.formatwarning = warning_simple  # Formatting of warnings for peaks user errors
        warn_str = 'Normal emission angles written to original data: ' + str(norm_angles)
        warnings.warn(warn_str)
        warnings.simplefilter('once', UserWarning)  # Reset warnings display and formatting - Give warnings first time only
        warnings.formatwarning = warning_standard  # Formatting of warnings for peaks user errors

    if plot == True:
        # Take the cross-correlation of these for display
        image_product = np.fft.fft2(data1.data) * np.fft.fft2(data2.data).conj()
        corr = np.fft.fftshift(np.fft.ifft2(image_product))

        # Work out the correlation axis ranges
        Nth = corr.shape[1]
        th0 = -np.floor(Nth / 2) * dth
        corr_th_vals = np.linspace(th0, -th0, Nth)
        Nmap = corr.shape[0]
        map0 = -np.floor(Nmap / 2) * dmap
        corr_map_vals = np.linspace(map0, -map0, Nmap)
        d_mapping = 'd_' + mapping_dim
        corr_xarray = xr.DataArray(corr.real, dims=[d_mapping, 'd_theta_par'],
                                   coords={d_mapping: corr_map_vals, 'd_theta_par': corr_th_vals})

        # Set up the plot
        fig, axes = plt.subplots(1, 2, figsize=(10,5))

        # Plot the cross correlation
        corr_xarray.plot(x='d_theta_par', ax=axes[0])
        axes[0].set_title('Cross-correlation')

        # Plot the original data with the norm emission lines
        data.plot(x='theta_par', ax=axes[1])
        axes[1].axhline(map_off)
        axes[1].axvline(th_off)
        axes[1].set_title('Estimated norm angles: \n'+str(norm_angles))
        plt.tight_layout()

    return norm_angles

# Function to return normal emission coordinates in manipulator angles
@add_methods(xr.DataArray)
def get_norm(data, offset_dict):
    ''' This function converts measured offset angles and returns corresponding normal emission values in manipulator angles

            Input:
                data - the corresponding scan (xarray)
                offset_dict - dictionary of offset angles (dict)

            Returns:
                norm_emission - the corresponding normal emission angles (dict) '''

    # Extract all manipulator and deflector angles
    manip_angles = get_angles(data, warn_flag=[])

    # Make dictionary to hold relevant normal emission data
    norm_emission = {}

    # Define beamline
    BL = data.attrs['beamline']
    # Get relevant sign conventions
    if BL in BL_angles.angles:
        BL_signs = BL_angles.angles[BL]
    else:
        BL_signs = BL_angles.angles['default']

    # Extract normal emission based on analyser configuration
    if manip_angles['ana_type'] == 'I' or manip_angles['ana_type'] == 'Ip':  # Type I, with or without deflector
        if 'theta_par' in offset_dict:
            norm_emission['norm_tilt'] = float(np.round(manip_angles['tilt'] + (BL_signs['defl_par'] * manip_angles['defl_par']) - (BL_signs['theta_par'] * offset_dict['theta_par']),3))
        if 'polar' in offset_dict:
            norm_emission['norm_polar'] = float(np.round(offset_dict['polar'] + (BL_signs['defl_perp'] * manip_angles['defl_perp']) + (BL_signs['ana_polar'] * manip_angles['ana_polar']), 3))
        if 'defl_perp' in offset_dict:
            norm_emission['norm_polar'] = float(np.round(manip_angles['polar'] + (BL_signs['defl_perp'] * offset_dict['defl_perp']) + (BL_signs['ana_polar'] * manip_angles['ana_polar']), 3))
        if 'ana_polar' in offset_dict:
            norm_emission['norm_polar'] = float(np.round(manip_angles['polar'] + (BL_signs['defl_perp'] * manip_angles['defl_perp']) + (BL_signs['ana_polar'] * offset_dict['ana_polar']), 3))
        if 'azi' in offset_dict:
            norm_emission['norm_azi'] = float(np.round(offset_dict['azi'] * BL_signs['azi'], 3))

    else:  # Type II, with or without deflector
        if 'theta_par' in offset_dict:
            norm_emission['norm_polar'] = float(np.round(manip_angles['polar'] + (BL_signs['defl_par'] * manip_angles['defl_par']) - (BL_signs['theta_par'] * offset_dict['theta_par']), 3))
        if 'tilt' in offset_dict:
            norm_emission['norm_tilt'] = float(np.round(offset_dict['tilt'] + (BL_signs['defl_perp'] * manip_angles['defl_perp']), 3))
        if 'defl_perp' in offset_dict:
            norm_emission['norm_tilt'] = float(np.round(manip_angles['tilt'] + (BL_signs['defl_perp'] * offset_dict['defl_perp']), 3))
        if 'azi' in offset_dict:
            norm_emission['norm_azi'] = float(np.round(offset_dict['azi'] * BL_signs['azi'], 3))

    return norm_emission